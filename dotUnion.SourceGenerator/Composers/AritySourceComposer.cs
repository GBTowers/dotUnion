using System.CodeDom.Compiler;
using dotUnion.SourceGenerator.Extensions;
using dotUnion.SourceGenerator.Model;
using Microsoft.CodeAnalysis;

// ReSharper disable ArgumentsStyleLiteral

namespace dotUnion.SourceGenerator.Composers;

public static class AritySourceComposer
{
	public static void BuildArity(SourceProductionContext context, FakeUnion fakeUnion)
	{
		using var output = new StringWriter();
		using var writer = new IndentedTextWriter(writer: output, tabString: "\t");

		writer.WriteLine("// <auto-generated/>");
		writer.WriteLine("#nullable enable");
		writer.WriteLine("using System;");
		writer.WriteLine("using System.Threading.Tasks;");
		writer.WriteLine();
		writer.WriteLine("namespace dotUnion;");
		writer.WriteLine();

		writer.WriteLine("[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"dotUnion.SourceGenerator\", \"1.0.0\")]");
		writer.WriteLine($"public abstract record {fakeUnion.Declaration}");
		writer.Indent++;
		writer.WriteLine(fakeUnion.WhereClauses);
		writer.Indent--;

		writer.WriteLine('{');
		writer.Indent++;

	#region Match

		// Match
		writer.WriteLine(
			$"public TOut Match<TOut>({fakeUnion.ArityMembers.JoinSelect(m => $"{m.FuncDeclaration} {m.FuncName}")}) =>"
		);

		writer.WriteSwitchExpression(arityMembers: fakeUnion.ArityMembers, isMatch: true);

		// MatchAsync
		writer.WriteLine(
			$"public Task<TOut> MatchAsync<TOut>({fakeUnion.ArityMembers.JoinSelect(m => $"{m.AsyncFuncDeclaration} {m.FuncName}")
			}) =>"
		);

		writer.WriteSwitchExpression(arityMembers: fakeUnion.ArityMembers, isMatch: true);

		// MatchAsyncValue
		writer.WriteLine(
			$"public ValueTask<TOut> MatchAsyncValue<TOut>({
				fakeUnion.ArityMembers.JoinSelect(m => $"{m.AsyncValueFuncDeclaration} {m.FuncName}")}) =>"
		);

		writer.WriteSwitchExpression(arityMembers: fakeUnion.ArityMembers, isMatch: true);

	#endregion

	#region Switch

		// Switch
		writer.WriteLine($"public void Switch({fakeUnion.ArityMembers.JoinSelect(m => $"{m.ActDeclaration} {m.ActName}")})");
		writer.WriteLine('{');
		writer.Indent++;
		writer.WriteLine("switch (this)");
		writer.WriteLine('{');
		writer.Indent++;
		foreach (ArityMember member in fakeUnion.ArityMembers)
			writer.WriteLine($"case {member.Name} {member.VariableName}: {member.ActName}({member.VariableName}); break;");

		writer.Indent--;
		writer.WriteLine('}');
		writer.Indent--;
		writer.WriteLine('}');
		writer.WriteLine();

		// SwitchAsync
		writer.WriteLine(
			$"public Task SwitchAsync({fakeUnion.ArityMembers.JoinSelect(m => $"{m.AsyncActDeclaration} {m.ActName}")}) =>"
		);

		writer.WriteSwitchExpression(arityMembers: fakeUnion.ArityMembers, isMatch: false);

		// SwitchAsyncValue
		writer.WriteLine(
			$"public ValueTask SwitchAsyncValue({
				fakeUnion.ArityMembers.JoinSelect(m => $"{m.AsyncValueActDeclaration} {m.ActName}")}) =>"
		);

		writer.WriteSwitchExpression(arityMembers: fakeUnion.ArityMembers, isMatch: false);

	#endregion


		writer.Indent--;
		writer.WriteLine('}');

		writer.WriteLine();

		string generatedFileName = $"Union.T{fakeUnion.Arity}.g." + $"cs";
		context.AddSource(hintName: generatedFileName, source: output.ToString());
	}

	private static void WriteSwitchExpression(
		this IndentedTextWriter writer,
		ArityMember[] arityMembers,
		bool isMatch
	)
	{
		writer.Indent++;
		writer.WriteLine("this switch");
		writer.WriteLine('{');
		writer.Indent++;

		foreach (ArityMember member in arityMembers)
			writer.WriteLine(
				isMatch
					? $"{member.Name} {member.VariableName} => {member.FuncName}({member.VariableName}),"
					: $"{member.Name} {member.VariableName} => {member.ActName}({member.VariableName}),"
			);

		writer.WriteLine("_ => throw new InvalidOperationException()");
		writer.Indent--;
		writer.WriteLine("};");
		writer.Indent--;
		writer.WriteLine();
	}
}
